using System.Collections.Generic;
using Unity.VisualScripting.Antlr3.Runtime.Tree;
using UnityEngine;

public static class Utils2D
{
    public static void LookAtTarget2D(this Transform transform, Transform target, Vector2 baseDirection)
    {
        if (target == null) return;
        
        Vector2 dirToTarget = (target.position - transform.position).normalized;
        LookDir2D(transform, dirToTarget, baseDirection);
    }

    public static void LookAtTarget2D_Lerp(this Transform transform, Transform target, Vector2 baseDirection, float lerp)
    {
        if (target == null) return;
        
        Vector2 dirToTarget = (target.position - transform.position).normalized;
        LookDir2D_Lerp(transform, dirToTarget, baseDirection, lerp);
    }
    
    public static void LookDir2D(this Transform transform, Vector2 direction, Vector2 baseDirection)
    {
        float targetAngle     = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        float baseOffsetAngle = Vector2.SignedAngle(Vector2.right, baseDirection);
        float finalAngle      = targetAngle - baseOffsetAngle;

        transform.rotation = Quaternion.Euler(0, 0, finalAngle);
    }

    public static void LookDir2D_Lerp(this Transform transform, Vector2 direction, Vector2 baseDirection, float lerp)
    {
        float targetAngle     = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        float baseOffsetAngle = Vector2.SignedAngle(Vector2.right, baseDirection);
        float finalAngle      = targetAngle - baseOffsetAngle;
        
        Quaternion targetRotation = Quaternion.Euler(0, 0, finalAngle);
        
        // Slerp를 사용하여 더 자연스러운 구면 보간을 적용
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, lerp);
    }
    /// <summary>
    /// 기본 오른쪽회전
    /// </summary>
    public static Vector2 Rotate(this Vector2 vector, float angleInDegrees)
    {
        float angleInRadians = -angleInDegrees * Mathf.Deg2Rad;
        float sinAngle       = Mathf.Sin(angleInRadians);
        float cosAngle       = Mathf.Cos(angleInRadians);

        float newX = vector.x * cosAngle - vector.y * sinAngle;
        float newY = vector.x * sinAngle + vector.y * cosAngle;

        return new Vector2(newX, newY);
    }
}

public static class Utils
{
       public static T GetRandom<T>(this List<T> list)
       {
              if (list == null || list.Count == 0)
              {
                     Debug.LogWarning("빈 리스트 혹은 null 리스트입니다.");
                     return default;
              }
              int randIndex = Random.Range(0, list.Count);
              return list[randIndex];
       }
       public static void DestroyAllReverse<T>(this List<T> components) where T : MonoBehaviour
       {
              for (int i = components.Count - 1; i >= 0; i--)
              {
                     if (components[i] != null)
                     {
                            Object.Destroy(components[i].gameObject);
                     }
              }
              components.Clear();
       }

       public static void MyDestroyGO(MonoBehaviour target)
       {
              Object.Destroy(target.gameObject);
       }
       

  // ──────────────── 1.  Fuzzy / Approximately comparisons ───────────────
        public static bool Approximately(this float a, float b, float tolerance = 0.0001f) =>
            Mathf.Abs(a - b) <= tolerance;

        public static bool Approximately(this Vector2 a, Vector2 b, float tolerance = 0.0001f) =>
            (a - b).sqrMagnitude <= tolerance * tolerance;

        public static bool Approximately(this Vector3 a, Vector3 b, float tolerance = 0.0001f) =>
            (a - b).sqrMagnitude <= tolerance * tolerance;

        public static bool IsZero(this Vector2 v, float tolerance = 0.0001f) =>
            v.sqrMagnitude <= tolerance * tolerance;

        public static bool IsZero(this Vector3 v, float tolerance = 0.0001f) =>
            v.sqrMagnitude <= tolerance * tolerance;

        // ──────────────── 2.  Vector “With” helpers ───────────────────────────
        public static Vector2 WithX(this Vector2 v, float x) => new Vector2(x, v.y);
        public static Vector2 WithY(this Vector2 v, float y) => new Vector2(v.x, y);

        public static Vector3 WithX(this Vector3 v, float x) => new Vector3(x, v.y, v.z);
        public static Vector3 WithY(this Vector3 v, float y) => new Vector3(v.x, y, v.z);
        public static Vector3 WithZ(this Vector3 v, float z) => new Vector3(v.x, v.y, z);

        // ──────────────── 3.  Color helpers ───────────────────────────────────
        public static Color WithAlpha(this Color c, float a) => new Color(c.r, c.g, c.b, a);

        // ──────────────── 4.  Math helpers ────────────────────────────────────
        public static float Remap(this float value,
                                  float from1, float to1,
                                  float from2, float to2) =>
            (value - from1) / (to1 - from1) * (to2 - from2) + from2;

        // ──────────────── 5.  GameObject / Component helpers ──────────────────
        public static T GetOrAddComponent<T>(this GameObject go) where T : Component
        {
            var comp = go.GetComponent<T>();
            if (comp == null) comp = go.AddComponent<T>();
            return comp;
        }

        public static bool IsInLayerMask(this GameObject go, LayerMask mask) =>
            (mask.value & (1 << go.layer)) != 0;

        public static void DestroyChildren(this Transform parent)
        {
            for (int i = parent.childCount - 1; i >= 0; i--)
            {
                Object.Destroy(parent.GetChild(i).gameObject);
            }
        }

        public static void ResetLocal(this Transform t)
        {
            t.localPosition = Vector3.zero;
            t.localRotation = Quaternion.identity;
            t.localScale     = Vector3.one;
        }

        // ──────────────── 6.  Collections helpers ─────────────────────────────
        public static void Shuffle<T>(this IList<T> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                int j = Random.Range(i, list.Count);
                (list[i], list[j]) = (list[j], list[i]);
            }
        }

        public static T GetSafe<T>(this IList<T> list, int index) where T : class
        {
            if (index < 0 || index >= list.Count)
            {
                return null;
            }
            return list[index];
        }
        public static T GetCyclicSafe<T>(this IList<T> list, int index) where T : class
        {
            if (list == null || list.Count == 0)
            {
                return null;
            }

            // 인덱스를 리스트 길이에 맞춰 순환시킴
            // 예를 들어, list.Count가 5일 때, index가 5이면 0, index가 -1이면 4가 됨.
            int actualIndex = index % list.Count;

            // 음수 인덱스 처리 (C#의 % 연산자는 음수를 반환할 수 있음)
            if (actualIndex < 0)
            {
                actualIndex += list.Count;
            }
        
            // 최종적으로 계산된 인덱스가 유효한 범위에 있는지 다시 한 번 확인 (안전장치)
            if (actualIndex < 0 || actualIndex >= list.Count)
            {
                // 이 경우는 거의 없지만, 예측 불가능한 상황을 대비
                return null;
            }

            return list[actualIndex];
        }
        public static Transform FindChildRecursive(Transform parent, string name)
        {
            // 부모의 모든 직속 자식을 순회합니다.
            foreach (Transform child in parent.GetComponentsInChildren<Transform>(true))
            {
                if (child.name == name)
                {
                    // 부모 자신은 제외하고, 이름이 일치하는 첫 번째 자식을 반환합니다.
                    if (child != parent) 
                    {
                        return child;
                    }
                }
            }
            return null; // 찾지 못하면 null을 반환합니다.
        }
}

public static class UtilsUI
{
    public static Vector2 WorldToCanvasPos(Vector3 pos, Camera cam, RectTransform canvasRect)
    {
        //풀스크린 기준으로 좌표가 나오게 된다. (ScreenSize)
        //좌하단이 0,0
        var uiPos = (Vector2)cam.WorldToScreenPoint(pos); 
        
        //캔버스 스케일러 고려
        var convertPos = uiPos / canvasRect.lossyScale;
        
        //캔버스는 중앙이 0,0 임으로.
        return convertPos - canvasRect.rect.size*0.5f;
    }
}
public class BiDictionary<T1, T2>
{
    private readonly Dictionary<T1, T2> _forward = new Dictionary<T1, T2>();
    private readonly Dictionary<T2, T1> _reverse = new Dictionary<T2, T1>();

    public void Add(T1 key, T2 value)
    {
        _forward.Add(key, value);
        _reverse.Add(value, key);
    }

    public bool TryGetValue(T1 key, out T2 value)
    {
        return _forward.TryGetValue(key, out value);
    }

    public bool TryGetKey(T2 value, out T1 key)
    {
        return _reverse.TryGetValue(value, out key);
    }

    public void RemoveByKey(T1 key)
    {
        if (_forward.TryGetValue(key, out T2 value))
        {
            _forward.Remove(key);
            _reverse.Remove(value);
        }
    }

    public void RemoveByValue(T2 value)
    {
        if (_reverse.TryGetValue(value, out T1 key))
        {
            _reverse.Remove(value);
            _forward.Remove(key);
        }
    }
    
    public int Count => _forward.Count;
}
