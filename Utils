using System.Collections.Generic;
using Unity.VisualScripting.Antlr3.Runtime.Tree;
using UnityEngine;

public static class Utils2D
{
    public static void LookAtTarget2D(this Transform transform, Transform target, Vector2 baseDirection)
    {
        if (target == null) return;
        
        Vector2 dirToTarget = (target.position - transform.position).normalized;
        LookDir2D(transform, dirToTarget, baseDirection);
    }

    public static void LookAtTarget2D_Lerp(this Transform transform, Transform target, Vector2 baseDirection, float lerp)
    {
        if (target == null) return;
        
        Vector2 dirToTarget = (target.position - transform.position).normalized;
        LookDir2D_Lerp(transform, dirToTarget, baseDirection, lerp);
    }
    
    public static void LookDir2D(this Transform transform, Vector2 direction, Vector2 baseDirection)
    {
        float targetAngle     = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        float baseOffsetAngle = Vector2.SignedAngle(Vector2.right, baseDirection);
        float finalAngle      = targetAngle - baseOffsetAngle;

        transform.rotation = Quaternion.Euler(0, 0, finalAngle);
    }

    public static void LookDir2D_Lerp(this Transform transform, Vector2 direction, Vector2 baseDirection, float lerp)
    {
        float targetAngle     = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        float baseOffsetAngle = Vector2.SignedAngle(Vector2.right, baseDirection);
        float finalAngle      = targetAngle - baseOffsetAngle;
        
        Quaternion targetRotation = Quaternion.Euler(0, 0, finalAngle);
        
        // Slerp를 사용하여 더 자연스러운 구면 보간을 적용
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, lerp);
    }
    /// <summary>
    /// 기본 오른쪽회전
    /// </summary>
    public static Vector2 Rotate(this Vector2 vector, float angleInDegrees)
    {
        float angleInRadians = -angleInDegrees * Mathf.Deg2Rad;
        float sinAngle       = Mathf.Sin(angleInRadians);
        float cosAngle       = Mathf.Cos(angleInRadians);

        float newX = vector.x * cosAngle - vector.y * sinAngle;
        float newY = vector.x * sinAngle + vector.y * cosAngle;

        return new Vector2(newX, newY);
    }
}

public static class Utils
{
       public static T GetRandom<T>(this List<T> list)
       {
              if (list == null || list.Count == 0)
              {
                     Debug.LogWarning("빈 리스트 혹은 null 리스트입니다.");
                     return default;
              }
              int randIndex = Random.Range(0, list.Count);
              return list[randIndex];
       }
       public static void DestroyAllReverse<T>(this List<T> components) where T : MonoBehaviour
       {
              for (int i = components.Count - 1; i >= 0; i--)
              {
                     if (components[i] != null)
                     {
                            Object.Destroy(components[i].gameObject);
                     }
              }
              components.Clear();
       }

       public static void MyDestroyGO(MonoBehaviour target)
       {
              Object.Destroy(target.gameObject);
       }
       

  // ──────────────── 1.  Fuzzy / Approximately comparisons ───────────────
        public static bool Approximately(this float a, float b, float tolerance = 0.0001f) =>
            Mathf.Abs(a - b) <= tolerance;

        public static bool Approximately(this Vector2 a, Vector2 b, float tolerance = 0.0001f) =>
            (a - b).sqrMagnitude <= tolerance * tolerance;

        public static bool Approximately(this Vector3 a, Vector3 b, float tolerance = 0.0001f) =>
            (a - b).sqrMagnitude <= tolerance * tolerance;

        public static bool IsZero(this Vector2 v, float tolerance = 0.0001f) =>
            v.sqrMagnitude <= tolerance * tolerance;

        public static bool IsZero(this Vector3 v, float tolerance = 0.0001f) =>
            v.sqrMagnitude <= tolerance * tolerance;

        // ──────────────── 2.  Vector “With” helpers ───────────────────────────
        public static Vector2 WithX(this Vector2 v, float x) => new Vector2(x, v.y);
        public static Vector2 WithY(this Vector2 v, float y) => new Vector2(v.x, y);

        public static Vector3 WithX(this Vector3 v, float x) => new Vector3(x, v.y, v.z);
        public static Vector3 WithY(this Vector3 v, float y) => new Vector3(v.x, y, v.z);
        public static Vector3 WithZ(this Vector3 v, float z) => new Vector3(v.x, v.y, z);

        // ──────────────── 3.  Color helpers ───────────────────────────────────
        public static Color WithAlpha(this Color c, float a) => new Color(c.r, c.g, c.b, a);

        // ──────────────── 4.  Math helpers ────────────────────────────────────
        public static float Remap(this float value,
                                  float from1, float to1,
                                  float from2, float to2) =>
            (value - from1) / (to1 - from1) * (to2 - from2) + from2;

        // ──────────────── 5.  GameObject / Component helpers ──────────────────
        public static T GetOrAddComponent<T>(this GameObject go) where T : Component
        {
            var comp = go.GetComponent<T>();
            if (comp == null) comp = go.AddComponent<T>();
            return comp;
        }

        public static bool IsInLayerMask(this GameObject go, LayerMask mask) =>
            (mask.value & (1 << go.layer)) != 0;

        public static void DestroyChildren(this Transform parent)
        {
            for (int i = parent.childCount - 1; i >= 0; i--)
            {
                Object.Destroy(parent.GetChild(i).gameObject);
            }
        }

        public static void ResetLocal(this Transform t)
        {
            t.localPosition = Vector3.zero;
            t.localRotation = Quaternion.identity;
            t.localScale     = Vector3.one;
        }

        // ──────────────── 6.  Collections helpers ─────────────────────────────
        public static void Shuffle<T>(this IList<T> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                int j = Random.Range(i, list.Count);
                (list[i], list[j]) = (list[j], list[i]);
            }
        }

        public static T GetSafe<T>(this IList<T> list, int index) where T : class
        {
            if (index < 0 || index >= list.Count)
            {
                return null;
            }
            return list[index];
        }
}
